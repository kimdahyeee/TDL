# `Collection`과 `Map`

> 각각의 자료구조에 대한 이해와 언제 어떤 자료구조를 사용할 지 결정하는 것은 중요하다.

## `Collection`과 `Map` 인터페이스의 이해
### `Collection` : 가장 상위 인터페이스
- `Set` : **중복을 허용하지 않는 집합**을 처리하기 위한 인터페이스
    - `SortedSet` : **오름차순**을 갖는 `Set` 인터페이스
    - `HashSet` : 데이터를 해쉬 테이블에 담는 클래스로 **순서 없이 저장**
    - `TreeSet` : `red-black` 이라는 트리에 데이터를 담는다. 값에 따라 순서가 정해진다. 데이터를 담으면서 동시에 정렬을 하기 때문에 `HashSet` 보다 성능상 느리다.
- `List` : **순서가 있는 집합**을 처리하기 위한 인터페이스
    - `Vector` : 객체 생성 시 크기를 지정할 필요가 없다. `synchronized` 처리되어 있다.
    - `ArrayList` : `Vector` 와 유사, `synchronized` 처리되어 있지 않다.
- `Queue` : **여러개의 객체를 처리하기 전에 담아서 처리할 때 사용**하기 위한 인터페이스
  - `LinkedList` : `ArrayList` 와 유사, `Queue` 인터페이스 구현하고 있음 (FIFO)

## `Map` : **키와 값**의 쌍으로 구성된 객체의 집합을 처리하기 위한 인터페이스
- `SortedMap` : **키를 오름차순으로 정렬** 하는 인터페이스
- `HashMap` : 데이터를 해쉬 테이블에 담는 클래스로, `HaspTable` 클래스와 다른 점은 `null` 값을 허용한다는 것과 동기화되어 있지 않다는 것


## 🤔 배열과 `List` 의 차이는?

배열 과 `List`의 가장 큰 차이
- 배열은 처음부터 크기를 지정해야 한다.
- `List`는 그럴 필요 없이 객체들이 채워질 때 마다 자동으로 크기가 증가한다.

> `List`는 데이터의 개수를 확실히 모를 때 유용하게 사용된다. ArrayList 는 내부적으로 **배열**을 사용한다.

## 🤔 `List` 관련 클래스 성능 비교
`ArrayList`, `Vector`, `LinkedList` 대상으로 비교
- 데이터 추가 (`add`)
  - `ArrayList` < `Vector` < `LinkedList`
  - 성능 차이 거의 없음
- 데이터 읽기 (`get`)
  - `ArrayList` <<< `Vector` <<<<< `LinkedList`
    - `ArrayList` 와 `Vector` 가 성능차이가 심한 이유?
      - `Vector`는 여러 스레드에서 접근을 방지하기 위해 내부적으로 `synchronized` 가 선언되어 있다.
  - `LinkedList` 를 사용할 경우, `peek()` 을 통해 데이터를 읽으면 크게 성능이 개선된다.
    - 내부적으로 `queue` 를 상속했기 때문
- 데이터 삭제 (`remove`)
  - 데이터 삭제 시에는 첫 요소를 사용할 때와 마지막 요소를 삭제하는 경우를 비교하자.
    - `ArrayList` 와 `Vector`는 첫 요소를 삭제하는 경우, 전체 정렬이 일어나기 때문에 마지막 요소를 삭제하는 경우보다 성능 상 좋지 않다.
    - `LinkedList`는 첫 요소와 마지막 요소를 삭제하는 것에 성능상 차이가 거의 없다.
      - `LinkedList`는 `queue` 를 상속하기 때문에 별도의 전체 정렬이 일어나지 않는다.

## 🤔 `List`도 순서를 보장하고, `Queue`도 순서를 보장하는데, 순서를 보장하는 경우 `Queue`를 사용하는 이유는 ?
`List`의 가장 큰 단점은 **데이터가 많은 경우** 처리 시간이 늘어난다는 점이다.
- 가장 앞에 있는 데이터(0번 데이터)를 지우면 그 다음 1번 데이터부터 마지막 데이터까지 한 칸씩 옮기는 작업을 수행하게 된다. 
  (데이터가 많을수록 이 작업을 수행하는 데 소요되는 시간이 증가된다.)
  
## 🤔 `HashSet`, `LinkedHashSet` vs `TreeSet`
`HashSet`과 `LinkedHashSet` 에 비해 성능상 느리다. `add()`, `contains()` 에 대해..

상대적으로 성능상 느리지만, `TreeSet`을 만든 이유는 **데이터를 순서에 따라 탐색하는 작업이 필요할 때**는 `TreeSet`을 사용하는 것이 좋다.
이런 경우가 아니라면 `HashSet`이나 `LinkedHashSet` 을 사용하는 것이 좋다.

## 블로킹 큐
크기가 지정되어 있는 큐에 더이상 공간이 없을 때, 공간이 생길 때 까지 대기하도록 만들어진 큐를 의미한다.

## 자료구조는 크기를 정할 수 있는 데, 크기를 정하는 경우와 정하지 않는 경우의 차이는 ?
보통 데이터의 크기를 알고 있는 경우엔, 객체 생성 시 크기를 미리 지정하는 것이 성능 상 유리하다.

## 참고
- 자바 성능 튜닝 이야기
